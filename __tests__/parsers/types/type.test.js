const {
  toValue,
  parse
} = require("arcsecond")
const type = require("../../../parsers/types/type")
const Type = require("../../../tree/Type")

test("single", () => {
  const value = toValue(parse(type)("False"))
  expect(value).toBeInstanceOf(Type)
  expect(value.name).toBe("False")
})

test("named", () => {
  const value = toValue(parse(type)("k: String"))
  expect(value).toBeInstanceOf(Type)
  expect(value.keys).toEqual(["k"])
  expect(value.name).toBe("String")
  expect(value.fullName).toBe("k: String")
})

test("sum", () => {
  const value = toValue(parse(type)("Number | Boolean"))
  expect(value).toBeInstanceOf(Type)
  expect(value.name).toBe("Number | Boolean")
  expect(value.types).toEqual([])
  expect(value.options.length).toBe(2)
  expect(value.options[0]).toBeInstanceOf(Type)
  expect(value.options[0].name).toBe("Number")
  expect(value.options[1]).toBeInstanceOf(Type)
  expect(value.options[1].name).toBe("Boolean")
})

test("tuple", () => {
  const value = toValue(parse(type)("String, String"))
  expect(value).toBeInstanceOf(Type)
  expect(value.isCompound).toBe(true)
  expect(value.name).toBe("String, String")
  expect(value.options).toEqual([])
  expect(value.types.length).toBe(2)
  expect(value.types[0]).toBeInstanceOf(Type)
  expect(value.types[0].name).toBe("String")
  expect(value.types[1]).toBeInstanceOf(Type)
  expect(value.types[1].name).toBe("String")
})

test("compound", () => {
  const value = toValue(parse(type)("name: String, age: Number"))
  expect(value).toBeInstanceOf(Type)
  expect(value.isCompound).toBe(true)
  expect(value.fullName).toBe("name: String, age: Number")
  expect(value.name).toBe(value.fullName)
  expect(value.options).toEqual([])
  expect(value.types.length).toBe(2)
  expect(value.types[0]).toBeInstanceOf(Type)
  expect(value.types[0].fullName).toBe("name: String")
  expect(value.types[1]).toBeInstanceOf(Type)
  expect(value.types[1].fullName).toBe("age: Number")
})

test("function", () => {
  const value = toValue(parse(type)("name: String, age: Number -> Boolean"))
  expect(value).toBeInstanceOf(Type)
  expect(value.isCompound).toBe(false)
  expect(value.isFunction).toBe(true)
  expect(value.types.length).toBe(1)
  expect(value.types[0]).toBeInstanceOf(Type)
  expect(value.types[0].name).toBe("Boolean")
  expect(value.inputTypes.length).toBe(2)
  expect(value.inputTypes[0]).toBeInstanceOf(Type)
  expect(value.inputTypes[0].fullName).toBe("name: String")
  expect(value.inputTypes[1]).toBeInstanceOf(Type)
  expect(value.inputTypes[1].fullName).toBe("age: Number")
  expect(value.fullName).toBe("name: String, age: Number -> Boolean")
})

test("function to tuple", () => {
  const value = toValue(parse(type)("n: Number -> Number, Boolean"))
  expect(value).toBeInstanceOf(Type)
  expect(value.isCompound).toBe(true)
  expect(value.isFunction).toBe(true)
  expect(value.types.length).toBe(2)
  expect(value.types[0]).toBeInstanceOf(Type)
  expect(value.types[0].name).toBe("Number")
  expect(value.types[1]).toBeInstanceOf(Type)
  expect(value.types[1].name).toBe("Boolean")
  expect(value.inputTypes.length).toBe(1)
  expect(value.inputTypes[0]).toBeInstanceOf(Type)
  expect(value.inputTypes[0].fullName).toBe("n: Number")
  expect(value.fullName).toBe("n: Number -> Number, Boolean")
})
